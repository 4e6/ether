<!doctype html>
<html>
    <head>
        <link href='https://fonts.googleapis.com/css?family=Ubuntu+Mono|Ubuntu&subset=latin,latin-ext' rel='stylesheet' type='text/css'>
        <style>
html, body {
    margin: 0;
    padding: 0;
}
a {
    color: inherit;
}
a:hover {
    color: #0a9bf0;
}
body {
    font-family: 'Ubuntu', sans-serif;
    font-size: 20px;
    color: #444;
}
pre, code {
    font-family: 'Ubuntu Mono', monospace;
    font-size: 0.9em;
}
h1 {
    margin-top: 2em;
}
section {
    display: block;
    padding: 0;
    margin: 0;
}
.section {
    display: block;
    margin: 0 auto;
    max-width: 50em;
}
section:first-child {
    font-size: 6em;
    display: -webkit-box;
    display: -webkit-flex;
    display: -ms-flexbox;
    display: flex;
    -webkit-flex-flow: column;
        -ms-flex-flow: column;
            flex-flow: column;
    -webkit-justify-content: space-around;
        -ms-flex-pack: distribute;
            justify-content: space-around;
    -webkit-box-align: center;
    -webkit-align-items: center;
        -ms-flex-align: center;
            align-items: center;
    color: #0a9bf0;
    margin-top: 1em;
    margin-bottom: 1em;
}
section:first-child h1 {
    text-align: center;
    margin: 0;
}
section:first-child h2 {
    font-size: 0.4em;
}
li {
    margin-top: 0.5em;
    margin-bottom: 0.5em;
}
blockquote, .source {
    border-left: 2px solid #0a9bf0;
    padding-left: 2em;
    padding-right: 2em;
    margin-left: 2em;
}
body > footer {
    padding: 1em;
    text-align: center;
}
.hint::before { content: '[' }
.hint::after  { content: ']' }
.hint {
    color: #999;
}
.source {
    background: #444;
    color: white;
    display: table;
    min-width: 50%;
    padding-top: 0.5em;
    padding-bottom: 0.5em;
    border-color: white;
}
.kw {
    color: #6bcffa;
}
.lit {
    color: #eee890;
}

#forkongithub a {
  background: #0a9bf0;
  color: white;
  text-decoration: none;
  text-align: center;
  font-weight: bold;
  padding: 5px 40px;
  font-size: 16px;
  font-size: 1rem;
  line-height: 32px;
  line-height: 2rem;
  width: 200px;
  position: absolute;
  top: 60px;
  right:-60px;
  -webkit-transform:rotate(45deg);
      -ms-transform:rotate(45deg);
          transform:rotate(45deg);
}
#forkongithub a:before,
#forkongithub a:after {
  content: "";
  width: 100%;
  display: block;
  position: absolute;
  top: 1px;
  left: 0;
  height: 1px;
  background: #0a9bf0;
}
#forkongithub a:after {
  bottom: 1px;
  top: auto;
}
#forkongithub {
  position: absolute;
  display: block;
  top: 0;
  right: 0;
  width: 200px;
  overflow: hidden;
  height: 200px;
  z-index: 9999;
}

@media screen and (max-width:1030px) {
    body { font-size: 1.6vw; }
}

        </style>
        <title>Ether: Monad Transformers and Classes</title>
    </head>
    <body>

      <span id="forkongithub">
        <a href="https://github.com/int-index/ether">Source on GitHub</a>
      </span>

      <main>
        <section>
            <h1>Ether</h1>
            <h2>Monad Transformers and Classes</h2>
        </section>
        <section>
        <div class="section">
            <h1>In Short</h1>
            <p>
              Ether is a Haskell library that extends <a href='https://hackage.haskell.org/package/mtl'>mtl</a> and <a href='https://hackage.haskell.org/package/transformers'>transformers</a> with tagged monad transformers and classes. Here are some resources to learn about the concept:
            <ul>
              <li>Blog post <a href='http://blog.sigfpe.com/2010/02/tagging-monad-transformer-layers.html'>Tagging Monad Transformer Layers</a> by Dan Piponi</li>
              <li>Paper <span class="hint">PDF</span> <a href='http://muddsnyder.com/pubs/monadfactory.pdf'>Monad Factory: Type-Indexed Monads</a> by Mark Snyder, Perry Alexander</li>
            </ul>
              See also Roman Cheplyaka's blog post <a href='https://ro-che.info/articles/2014-06-11-problem-with-mtl'>The problem with mtl</a>
              to see what exactly is the problem we're solving here.
            </p>
            <h1>Features</h1>
            <ul>
              <li>
                Tagged effects&mdash;now you can have multiple
                <code>MonadState</code>s, <code>MonadReader</code>s,
                <code>MonadWriter</code>s and <code>MonadExcept</code>s in
                your monad transformer stack.
              </li>
              <li>
                Mix tagged and untagged effects with no effort&mdash;regular
                transformers and classes can remain in your monad transformer stack.
              </li>
              <li>
                Turn untagged effects into tagged ones by wrapping them&mdash;no
                need to rewrite functions that use mtl.
              </li>
              <li>
                Different tagging styles (explicit and implicit)&mdash;no
                need to bother with tags if your types are unique.
              </li>
              <li>
                Simulate Java's checked exceptions, only better&mdash;list all
                exceptions your function can throw in its signature and handle
                them one by one.
              </li>
            </ul>
            <h1>The Code</h1>
            <blockquote>
                <p>Talk is cheap. Show me the code.</p>
                <footer>
                &mdash; <cite><a href="https://lkml.org/lkml/2000/8/25/132">Linus Torvalds</a></cite>
                </footer>
            </blockquote>
            <p>
              Ether's interface is similar to mtl's interface, except most
              functions require a tag. So let's create some tags:
<pre class="source">
ethereal <span class="lit">"Foo" "foo"</span>
ethereal <span class="lit">"Bar" "bar"</span>
</pre>
              <code>ethereal</code> is a Template Haskell function that expands
              to an empty data declaration and a value-level proxy. If for some
              reason you don't want to use Template Haskell, you can create tags
              manually like so:
<pre class="source">
<span class="kw">data</span> Foo
foo <span class="kw">=</span> Proxy <span class="kw">::</span> Proxy Foo
</pre>
              In fact, any data type of kind <code>*</code> can serve as a tag.
              Later we'll see how it's used for implicit tagging.
            </p>
            <p>
              But for now let's stick to our newly created tags <code>Foo</code>
              and <code>Bar</code>. We define a function that uses multiple
              <code>MonadReader</code>s (something impossible with mtl):
<pre class="source">
add <span class="kw">::</span> ( Num a
       <span class="kw">,</span> MonadReader Foo a m
       <span class="kw">,</span> MonadReader Bar a m
       ) <span class="kw">=&gt;</span> m a
add <span class="kw">=</span> liftA2 (+) (ask foo) (ask bar)

n <span class="kw">::</span> Num a <span class="kw">=&gt;</span> a
n <span class="kw">=</span> runReader foo (runReaderT bar add 10) 20
</pre>
              Here we can see that <code>MonadReader</code>, <code>ask</code>,
              <code>runReader</code> and <code>runReaderT</code> are used just
              like the ones from mtl, only with a tag. As you might expect,
              <code>n</code> here equals <code>30</code> (or
              <code>30.0</code>&mdash;the reader environment can be
              polymorphic).
            </p>
            <p>
              Tagged versions of <code>MonadState</code>, <code>MonadWriter</code>
              and <code>MonadExcept</code> are provided as well. There's no
              tagged <code>MonadCont</code> because I couldn't think of a use
              case for multiple <code>MonadCont</code>s in a monad transformer
              stack.
            </p>
            <p>
              Ether's classes are fully compatible with ones from mtl's,
              meaning that you can use Ether with your existing code without
              unnecessary changes. Consider the following code snippet:
<pre class="source">
summator
    <span class="kw">::</span> ( Num a
       <span class="kw">,</span> MonadWriter (Sum a) m
       ) <span class="kw">=&gt;</span> [a] <span class="kw">-&gt;</span> m ()
summator xs <span class="kw">=</span> do
    for_ xs <span class="kw">$ \</span>x <span class="kw">-&gt;</span> tell (Sum x)
</pre>
              Now, say you want to add another <code>MonadWriter</code> to count
              how many numbers you've summed up. As we know, it's impossible
              with mtl alone, but you can combine the existing untagged
              <code>MonadWriter</code> with a tagged one:
<pre class="source">
<span class="kw">import qualified</span> Control.Monad.Ether.Writer <span class="kw">as</span> Ether

summator
    <span class="kw">:: (</span> Num a
       <span class="kw">,</span> MonadWriter (Sum a) m
       <span class="kw">,</span> Ether.MonadWriter Foo (Sum a) m
       ) <span class="kw">=&gt;</span> [a] <span class="kw">-&gt;</span> m ()
summator xs <span class="kw">=</span> do
    for_ xs <span class="kw">$ \</span>x <span class="kw">-&gt; do</span>
        tell (Sum x)
        Ether.tell foo (Sum 1)
</pre>
              Easy, right? Untagged classes can be considered a special case of
              tagged ones, and any mix of them should Just Work&trade;. But
              wait, there's more...
            </p>
            <p>
              What if you have two functions, both requiring a <code>MonadState</code>,
              but it's different <code>MonadState</code>s? There's no way you could
              use those functions in one monad transformer stack with mtl, thus
              <em>mtl is antimodular!</em>
              However, Ether comes to the rescue with its wrapping mechanism:
<pre class="source">
f <span class="kw">::</span> MonadState Int m <span class="kw">=&gt;</span> m String
f <span class="kw">= </span><em>omitted</em>

g <span class="kw">::</span> MonadState Bool m <span class="kw">=&gt;</span> m String
g <span class="kw">= </span><em>omitted</em>

useboth
    <span class="kw">:: (</span> Ether.MonadState Foo Int  m
       <span class="kw">,</span> Ether.MonadState Bar Bool m
       ) <span class="kw">=&gt;</span> m String
useboth <span class="kw">=</span> do
    a <span class="kw">&lt;-</span> ethered foo f
    b <span class="kw">&lt;-</span> ethered bar g
    return (a <span class="kw">++</span> b)
</pre>
              Here we use the <code>ethered</code> function
              from <code>Control.Ether.Wrapped</code>
              to turn untagged transformers into tagged ones.
            </p>
            <p>
              On this wave of modularity features I'd like to present you another
              one: simulating checked exceptions from Java. It's as simple as
              having one <code>MonadExcept</code> per exception:
<pre class="source">
<span class="kw">data</span> DivideByZero <span class="kw">=</span> DivideByZero
<span class="kw">data</span> NegativeLog  <span class="kw">=</span> NegativeLog

logDiv
    ( Floating a
    <span class="kw">,</span> Ord a
    <span class="kw">,</span> MonadExcept Foo DivideByZero m
    <span class="kw">,</span> MonadExcept Bar NegativeLog  m
    ) <span class="kw">=&gt;</span> a <span class="kw">-&gt;</span> a <span class="kw">-&gt;</span> m a
logDiv x y <span class="kw">=</span> do
    when (y <span class="kw">==</span> 0) (throw foo DivideByZero)
    let d <span class="kw">=</span> x<span class="kw">/</span>y
    when (d <span class="kw">&lt;</span> 0) (throw bar NegativeLog)
    return (log d) 
</pre>
              Now we can handle those exceptions one by one with <code>runExceptT</code>.
              However, this tagging business starts to become unmanagable. Do we
              also need to create a tag per exception? The answer, fortunately,
              is no: since exceptions tend to be monomorphic, we can use them
              as tags for their classes. This feature is called implicit
              tagging, and we can rewrite the example above like so:
<pre class="source">
<span class="kw">import qualified</span> Control.Monad.Ether.Implicit.Except <span class="kw">as</span> I

logDiv
    ( Floating a
    <span class="kw">,</span> Ord a
    <span class="kw">,</span> MonadExcept DivideByZero m
    <span class="kw">,</span> MonadExcept NegativeLog  m
    ) <span class="kw">=&gt;</span> a <span class="kw">-&gt;</span> a <span class="kw">-&gt;</span> m a
logDiv x y <span class="kw">=</span> do
    when (y <span class="kw">==</span> 0) (I.throw DivideByZero)
    let d <span class="kw">=</span> x<span class="kw">/</span>y
    when (d <span class="kw">&lt;</span> 0) (I.throw NegativeLog)
    return (log d) 
</pre>
            That's better. In fact, implicit tagging can be used with polymorphic
            tags too, but its behavior can be sometimes unobvious. You also may
            need to use type annotations when using implicit tagging, so for
            anything polymorphic prefer the explicit style.
            </p>
            <h1>&mdash; This is magic!</h1>
            <p>
              I agree. Now go get it, <a href="https://hackage.haskell.org/package/ether">it's on Hackage</a>.
              I have no idea why no one else wrote such a package, as I am
              not the first one to discover the solution.
            </p>
        </div>
        </section>
      </main>
      <footer>
        <a href="https://github.com/int-index">Index Int</a>, 2015
      </footer>
    </body>
</html>
